---
layout: post
title: "Greedy Algorithm"
date: 2022-04-30 08:44:38 -0400
category:  algorithm
subcategory: 
author: eun
short-description: 최적화 문제를 대상으로하는 그리디 알고리즘
use_math: true
---

#### intro
---
**그리디 알고리즘**`Greedy Algorithm`은 바로 눈앞의 이익만을 좇는 알고리즘을 말한다.
대부분의 경우에는 뛰어난 결과를 도출하지 못하지만, 드물게 최적해를 보장하는 경우도 있다.

- 그리디 알고리즘은 **최적화 문제**를 대상으로 한다.
- 목표
    + 최적해 찾기
    + 최적해를 찾을 수 없다면: 주어진 시간 내에 가장 괜찮은 해를 찾는 것

대부분의 문제들은 이런 로컬 최적해`Locally Optimum Solution`를 찾는 그리디 방법으로 문제를 해결할 수 없다. 
그러나 <u>합리적인 시간 내에 최적에 가까운 답을 찾을 수 있다는 점에서 매우 유용한 알고리즘</u>이다. 

<br>

#### Greedy Algorithm
---

- **그리디 알고리즘이 잘 작동하는 문제**
    + **탐욕 선택 속성**`Greddy Choice Property`를 가지고 있는 **최적 부분 구조**`Optimal Substructure`인 문제이다.
    + 탐욕 선택 속성: 앞의 선택이 이후 선택에 영향을 주지 않는 것(그리디 알고리즘은 선택을 다시 고려하지 않음)
    + 최적 부분 구조: 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성

위 2가지 조건을 만족하면 최적해를 찾을 수 있다. 
하지만 그렇지 않더라도 그리디 알고리즘은 정답을 근사하게 찾는 용도로 활용할 수 있으며, 대부분의 경우 계산 속도가 빠르므로 매우 실용적이다.

- 그리디 알고리즘이 잘 작동하는 예
    + 다익스트라 알고리즘, 최단 경로 문제
    + 압축 알고리즘인 허프만 코딩 알고리즘, 허프만 트리 빌드할 때 
    + ID3 알고리즘, 머신러닝 분야의 의사결정 트리 알고리즘 

그리디 알고리즘은 최적 부분 구조 문제를 푼다는 점에서 다이나믹 프로그래밍과 비교되는데, 서로 풀 수 있는 문제의 성격이 다르며 알고리즘의 접근 방식 또한 다르다. 

- 다이나믹 프로그래밍
    + 하위 문제에 대한 최적의 솔루션을 찾은 다음, 이 결과들을 결합한 정보에 입각한 전역 최적 솔루션을 선택한다
- 그리디 알고리즘
    + 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태

서로 반대 방향으로 접근하는 구조이다.


<br>

#### Knapsack Problem
---
**배낭 문제**`Knapsack Problem`는 조합 최적화`Combinatorial Optization` 분야의 매우 유명한 문제이다.

<p align="center"><img src="/assets/images/greedy_01.png"  width="50%" height="50%"></p>

위 그림처럼 배낭에 담을 수 있는 무게의 최댓값(15kg)이 정해져 있고 각 짐의 가치($ 단위)와 무게(kg 단위)가 있는 짐들을 배낭에 넣을 때 가치의 합이 최대가 되도록, 달러의 가치가 최대가 되도록 짐을 고르는 방법을 찾는 문제이다.

배낭 문제는 2가지로 나뉜다.
1. 짐을 쪼갤 수 있는 경우인 분할 가능 배낭 문제(그리디 달고리즘으로 해결)
2. 짐을 쪼갤 수 없는 경우인 배낭 문제(다이나믹 프로그래밍으로 해결) 

먼저 **분할 가능 배낭 문제**를 살펴보자.
- 단가가 높은 짐부터 차례대로 채워나가면 된다. 
- C의 단가가 2.5달러로 가장 높으므로 C, B, E, D 순으로 8kg의 짐을 배낭에 담고
- 마지막 남은 7kg을 위해 A의 $7\over12$을 쪼개서 배낭에 담는다.
- 이렇게 하면 17.3이라는 최적해를 찾을 수 있다.

이 부분을 코드로 구현해보면 다음과 같다

```python
cargo = [
    (4, 12),
    (2, 1),
    (10, 4),
    (1, 1),
    (2, 2),
]

r = fractional_knapsack(cargo)
```

먼저 짐 cargo를 '(가격, 무게)'의 튜플 리스트로 정의하고, 함수 fractional_knapsack()을 호출한다.
우선, 앞서 단가 기준으로 알고리즘을 설명한 그대로 구현하기 위해 단가를 계산하고 역순으로 정렬한다. 
즉, 가장 단가가 높은 짐이 맨 위에 오도록 구현한다.

```python
for c in cargo:
    pack.append((c[0]/c[1], c[0], c[1]))
pack.sort(reverse=True)
```

이제 단가 순으로 그리디 알고리즘을 계산하면 된다. 전체 구현 코드는 깃허브에서 확인할 수 있다.
[GitHub](https://github.com/JJungEEun/CodingTest/blob/main/interviews/chap21_%EA%B7%B8%EB%A6%AC%EB%94%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B0%EB%82%AD%20%EB%AC%B8%EC%A0%9C.ipynb)

이처럼 구현했을 때 total_value는 17.3인 것을 확인할 수 있다. 앞서 알고리즘을 설명했을 때와 동일한 정답이다.
하지만 이 문제에서 짐을 쪼갤 수 없다면, 지금까지 실행한 방식대로 단가순으로 배치해서는 안된다.
짐을 쪼갤 수 없는 배낭 문제는 다이나믹 프로그래밍에서 풀이를 확인할 수 있다.

<br>

#### Coin-Change Problem
---
**동전 바꾸기 문제**`Coin-Change Problem` 또한 유명한 문제이다. 동전의 액면이 10원, 50원, 100원처럼 증가하면서 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀 수 있다.
우리나라 동전은 항상 배수 이상이므로 그리디 알고리즘으로 풀 수 있다.

예를 들어 160원을 거슬러 준다면 10원짜리 16개보다, 100원짜리 하나 50원짜리 하나 10원짜리 하나로, 각각의 동전을 최대한 활용하는 그리디한 방법이 가장 작은 동전 개수로 거슬로 줄 수 있다.

다른 나라에 80원짜리 동전이 있다고 가정해보자. 이 경우 더 이상 그리디한 방법으로 풀이할 수 없다. 160원을 거슬러줘야하면 80원짜리 2개가 정답이다.
하지만 그리디 알고리즘은 100원부터 선택하게 될 것이고 이렇게 하면 80원 2개로 풀이할 수 없기 때문이다. 이 경우 다이나믹 프로그래밍을 이용해 풀이해야 한다.

<br>

#### 