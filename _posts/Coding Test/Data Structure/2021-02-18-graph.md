---
layout: post
title: "Graph"
date: 2021-02-17 08:44:38 -0400
category:  data-structure
subcategory: 
author: eun
short-description: 객체의 일부 쌍들이 '연관되어' 있는 객체 집합 구조, 그래프
---

#### intro
지금으로부터 300여 년 전 프로이센 공국의 쾨니히스베르크에는 프레겔 강이 흐르고 있었다.
어느날 도시의 시민 한 명이 "이 7개 다리를 한 번씩만 건너서 모두 지나갈 수 있을까?"라는 흥미로운 문제를 냈다. 
그러나 쉽게 풀릴 것처럼 보였던 이 문제를 풀 수 있는 이는 아무도 없었다.

'수학의 모차르트'라 불리는 레온하르트 오일러가 '괴니히스베르크의 다리 문제'를 조사하기 시작했다.
오일러는 이 문제가 도형 문제처럼 보이지만, 당시까지 알려진 기하학으로는 풀 수 없음을 알아냈다.
그리고 미지의 영역 그 해법이 있다는 사실을 천재적인 작관으로 간파했다. 이것이 **'그래프 이론**의 시작이다.


#### Graph Traversals
**그래프 순회**는 그래프 탐색이라고 불리며 그래프의 각 정점을 방문하는 과정을 의미한다. 
1. 깊이 우선 탐색(`Depth-First Search`)
2. 너비 우선 탐색(`Breadth-First Search`)

- 일반적으로 BFS에 비해 DFS가 주로 사용
- 코딩테스트 시에도 대부분의 그래프 탐색은 DFS로 구현하게 될 것
- 인접 행렬`Adjacency Matrix`와 인접 리스트`Adjaceny List` 2가지 방법으로 표현 가능
- 인접 리스트
    + 인접 리스트는 출발 노드를 키로, 도착 노드를 값으로 표현할 수 있다.      
    + 도착 노드는 여러개가 될 수 있으므로 리스트 형태가 된다.     
    + 파이썬의 딕셔너리 자료형으로 다음과 같이 나타낼 수 있다. 

    ![Image Alt 텍스트](/assets/images/ct05_01.png){: width="15%" height="15%"}     
    <p style="font-size: 0.8em">위 그림은 인접 리스트를 사용해 표현 그래프</p>      
    ```python
    graph = {
        1: [2,3,4],
        2: [5],
        3: [5],
        4: [],
        5: [6,7],
        6: [],
        7: [3]
    }
    ```

#### Depth-First Search
- 자식 노드를 우선적으로 탐색하는 기법
- 주로 스택으로 구현하거나 재귀로 구현


**재귀 구조로 구현**
```python
def re_dfs(v, dfs=[]):
    dfs.append(v)
    for w in graph[v]:
        if w not in dfs:
            dfs = re_dfs(w, dfs)
    return dfs

re_dfs(1)
>>> [1,2,5,6,7,3,4]
```
정점의 모든 인접 유향 간석들을 반복했다.
방문했던 정점, 즉 dfs를 계속 누적한 결과로 만들기 위해 리턴하는 형태만 받아오도록 처리했다. 

이 결과가 맞는지 확인하기 위해 DFS를 직접 손으로 그린 결과는 다음과 같다        
![Image Alt 텍스트](/assets/images/ct05_02.png){: width="20%" height="20%"}    

막다른 곳에 도달할 때까지 연속으로 진행되는 탐식이 총 3번에 걸쳐 진행됐다.      
1) 1->2->5->6       
2) 7->3     
3) 4

따라서 최종결과는 1->2->5->6->7->3->4이다.

**스택를 이용한 반복 구조로 구현**
```python
def iter_dfs(v):
    dfs = []
    stack = [v]
    while stack:
        v = stack.pop()
        if v not in dfs:
            dfs.append(v)
            for w in graph[v]:
                stack.append(w)
    return dfs
```