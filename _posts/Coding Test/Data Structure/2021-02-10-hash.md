---
layout: post
title: "Hash"
date: 2021-02-10 08:44:38 -0400
category:  data-structure
subcategory: 
author: eun
short-description: 키를 값에 매핑할 수 있는 구조인 연관 배열 추상 자료형, 해시 테이블

---

#### intro
해시 테이블 또는 해시 맵은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형을 구현한 자료구조이다.

#### Hash
**해시**는 키를 값에 매핑할 수 있는 구조인 자료구조이다. 해시테이블의 핵심은 해시함수이다. 

![Image Alt 텍스트](/assets/images/ct04_01.png){: width="60%" height="60%"}

위 그림은 해싱 함수를 통해 키가 해시 값으로 변경되는 과정을 도식화한 것이다.

- 해시함수를 사용해 키를 해시 값으로 매핑함
- 이 해시값을 인덱스 또는 주소삼아 데이터를 key와 함께 저장하는 자료구조
- key-value로 이루어진 자료구조 형태
- 대부분의 연산이 분할 상환 분석에 따른 **시간 복잡도: O(1)**
- 데이터 양에 관계 없이 빠른 성능을 기대할 수 있음

<p style="font-size: 1.12em">📌해시테이블의 구성 </p>

Key는 Hash Function을 통해 Hash로 변경 되며 Hash는 Value와 매칭되어 Bucket에 저장된다.
1. **key**는 고유한 값으로 해시함수에 Input된다.
- key 값을 그대로 저장소에 색인할 경우 key 길이만큼의 정보 저장공간이 필요하다.
- 그렇기 때문에 이 key 값을 고정된 길이의 해시로 변경한다
2. **Hash Function**는 임의의 크기 데이터를 고정 크기 값으로 매핑하는데 사용하는 함수이다.    
- 길이가 다양한 key 값을 고정된 크기의 hash로 변경해주는 역할  
- ex) ABC -> A1,  1234BC -> CB,  AF32B -> D5
- **해싱**: 이처럼 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것
- 해싱에는 다양한 알고리즘 존재
- 최상의 분포를 제공하는 방법은 데이터에 따라 다르다
- **해시 충돌**: 서로 다른 key가 hashing 후 같은 hash값이 나오는 경우
- 해시 충돌 발생 확률이 적을 수록 좋은 해시 함수이다.
- 해시 충돌이 많이 발생할 경우: 데이터 저장시 비효율적, 보안에도 취약       
3. **Hash**는 해시 함수의 결과물로, 저장소에 value와 매칭되어 저장된다.
4. **Value**는  저장소에 최종적으로 저장된 값으로, hash와 매칭되어 저장된다.
5. **Bucket, Slot**은 저장소이다.


<p style="font-size: 1.12em">📌해시테이블의 특징 </p>
해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것을 **해싱(`Hashing`)**이라 한다.
- **해싱**: **정보를 가능한 한 빠르게 저장하고 검색하기 위해** 사용하는 중요한 기법 중 하나
- 최적의 검색이 필요한 분야에 사용
- 심볼 테이블(일반적으로 해시 테이블)등 의 자료구조를 구현하기에 적합
- 체크섬, 손실 압축, 무작위화 함수, 암호 등과 관련이 깊음
- 용도와 요구사항에 따라 해시 함수는 각각 다르게 설계 및 최적화됨

**성능 좋은 해시 함수들의 특징**은 다음과 같다
+ 해시 함수 값 충돌의 최소화
+ 쉽고 빠른 연산
+ 해시 테이블 전체에 해시 값이 균일하게 분포
+ 사용할 키의 모든 정보를 이용하여 해싱
+ 해시 테이블 사용 효율이 높을 것

##### The Birthday Paradox
해시 충돌은 생각보다 쉽게 일어난다. 흔한 예로 생일 문제(`Birthday Problem`)를 들 수 있다.

생일의 가짓수는 365개이므로, 여러 사람들이 모였을 떄 생일이 같은 2명이 존재할 확률을 얼핏 생각해보면
<a href = "#pigeonhole-principle">비둘기집 원리</a>에 따라 366명 이상이 모여야 일어나는 일 같다. 하지만 실제로 23명만 모여도 50%를 넘고, 57명이 모이면 그 때부터 99%을 넘어선다. 

![Image Alt 텍스트](/assets/images/ct04_02.png){: width="50%" height="50%"}

생일문제를 수식으로 증명하려면 어려운 계산이 필요하지만 파이썬을 활용하면 간단한 실험을 통해서 증명할 수 있다. 
정말로 23명만 있으면 생일이 같은 확률이 50%를 넘어설 수 있을까?
```python
TRIALS = 10000
same_birthdays = 0

#10만 번 실험 질행
for _ in range(TRIALS):
    birthdays = []
    #23명이 모여있을 때, 생일이 같을 경우 same_birthdays += 1
    for i in range(23):
        birthday = random.randint(1, 365)
        if birthday in birthdays:
            same_birthdays += 1
            break
        birthdays.append(birthday)

# 전체 10만번 실험 중 생일이 같은 실험의 확률
print(f'{same_birthdays / TRIALS * 100}%')
>>> 50.7%
```

23명이 모이는 경우를 각각 10만 번 실험한 결과, 생일이 같은 확률은 약 50.7%이다. 이처럼 일반적인(잘못된) 상식과 달리, **충돌은 생각보다 쉽게 발생한다. 충돌을 최소화하는 일을 무엇보다 중요하다.**

##### Pigeonhole principle
비둘기집 원리란 n개 아이템을 m개 컨테이너에 넣을 때, n>m이라면 **적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리**를 말한다. 

비둘기집 원리는 충돌의 원리를 잘 설명한다. 비둘기집 원리는 1834년 독일의 수학자 페터 디클레가 만든 것으로, 
'서랍원리'라고도 부른다. 간단한 귀류법으로 모순을 이끌어내 쉽게 증명할 수 있으며, 아래 사진으로도 쉽게 이해할 수 있다.

![Image Alt 텍스트](/assets/images/ct04_03.png){: width="50%" height="50%"}

비둘기집 원리에 따라 9개의 공간이 있는 곳에 10개의 아이템이 들어온다면 반드시 1번 이상은 충돌이 발생한다. 
좋은 해시 함수라면 단 1번의 충돌만 일어나겠지만, 좋지 않은 해시 함수의 경우라면 9번의 충돌이 발생할 수도 있다.
여러 번 충돌하는 것은 그만큼 추가 연산을 필요로 하기 때문에 가급적 충돌을 최소화하는 것이 좋다.

##### Load Factor
**로드 팩터**는 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k개로 나눈 것이다. 

`load factor` = `n` / `k`

로드 팩터 비율에 따라서 해시 함수는 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지 결정된다.
또한 이 값은 해시 함수가 키들을 잘 분산해 주는지를 말하는 효율성 측정에도 사용된다.
자바 10에서는 해시맵의 디폴트 로드 팩터를 0.75로 정하고 '시간과 공간 비용의 적절한 절충안'이라 말한다.
**일반적으로 로드 팩터가 증가할 수록 해시 테이블의 성능은 저하**되고, 자바 10의 경우 0.75를 넘어설 경우 동적 배열처럼 해시 테이블 공간을 재할당한다.

#### Collision
![Image Alt 텍스트](/assets/images/ct04_05.png){: width="40%" height="40%"}

아무리 좋은 해시 함수라도 위 그림처럼 충돌은 발생한다.
이 그림에서 윤아와 수영은 해시 값이 2로 같은 값이 되어 충돌이 발생한다. (빨간색 선)

이처럼 충돌이 발생할 경우 어떤 식으로 처리하는지 살펴보자.

##### Separate Chaining
![Image Alt 텍스트](/assets/images/ct04_06.png){: width="30%" height="30%"}     
입력값은 다음과 같고 해시는 키를 해싱한 결과이다. 그리고 '윤아'와 '수영'을 해싱한 결과는 충돌한 상태이다.

![Image Alt 텍스트](/assets/images/ct04_04.png){: width="60%" height="60%"}     
이 표를 개별 체이닝 방식으로 구현하면 다음과 같다.      
해시 테이블의 기본 방식이기도한 개별 체이닝은  충돌 발생시 위 그림과 같이 **연결 리스트로 연결하는 방식**이다.

이처럼 기본적인 자료구조와 임의로 정한 간단한 알고리즘만 있으면 되므로 개별 체이닝 방식은 인기가 높다. 
원래 헤시 테이블 구조의 원형이기도 하며 가장 전통적인 방식으로, 흔히 해시 테이블이라고 하면 이 방식을 말한다.

간단한 원리를 요약하면 다음과 같다.
1. 키의 해시 값을 계산한다.
2. 해시 값을 이용해 배열의 인덱스를 구한다.
3. 같은 인덱스가 있다면 연결 리스트로 구현한다.

잘 구현한 경우 대부분의 탐색은 O(1)이지만 최악의 경우(모든 해시 충돌 발생) O(n)이 된다. 

##### Open Addressing
**오픈 어드레싱** 방식은 충돌 발생시 탐사를 통해 빈 공간을 찾아내는 방식이다.
무한정 저장할 수 있는 체이닝 방식과 달리, 오픈 어드레싱 방식은 전체 슬롯의 개수 이상은 정할 수 없다.
충돌이 일어나면 테이블 공간 내에서 **탐사**를 통해 빈 공간을 찾아 해결한다. 이 떄문에 개별 체이닝 방식과 달리, **모든 원소가 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다**

![Image Alt 텍스트](/assets/images/ct04_07.png){: width="50%" height="50%"}     
오픈 어데르싱 방식 중 가장 간단한 방식인 **선형 탐사** 방식은 충돌이 발생할 경우 
해당 위치부터 순차적으로 탐사를 하나씩 진행한다. 
특정 위치가 선점되어 있으면 그 다음 위치를 확인하는 방식이다. 
이렇게 탐사를 진행하다가 비어 있는 공간을 발견하면 삽입하게 된다.

위 그림과 같이 수영의 해시값이 윤아의 해시값과 2로 동일하자 그 다음 위치인 3에 수영이 들어가게 된다. 
이처럼 선형 탐사 방식은 구현 방법이 간단하지만, 의외로 전체적인 성능이 좋은 편에 속한다.

[문제점]       
01) 클러스터링      
해시 테이블에 저장되는 데이터가 고르게 분포되지 않고 뭉치는 경향이 있다. 해시 테이블 여기저기에 연속되는 데이터 그룹이 생기는 현상을 **클러스터링**이라 부른다. 클러스터들이 점점 커지게 되면 인근 클러스터들과 서로 합쳐지는 일이 발생한다. 그렇게 되면 해시 테이블의 특정 위치에 데이터가 몰리게 되고, 다른 위치에는 상대적으로 데이터가 거의 없는 상태가 될 수도 있다. 

이러한 클러스터링 현상은 탐사 시간을 오래 걸리게 하며, 전체적으로 해싱 효율을 떠러뜨리는 원인이 된다.

02) 버킷 사이즈보다 큰 경우 삽입 불가       
오픈 어드레싱 방식은 버킷 사이즈보다 큰 경우 삽입할 수 없다. 따라서 일정 이상이 채워지면(기준 로드 팩터 비율 초과시)
그로스 펙터의 비율에 따라 더 큰 키기의 또 다른 버킷을 생성한다. 그후 여기에 새롭게 복사하는 리해싱 작업이 일어난다. 
이는 동적 배열에서 공간이 가득찰 경우, 더블링으로 새롭게 복사해서 옮겨가는 과정과 유사하다.